/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.1.0-beta.2.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import type { ActorMethod } from "@icp-sdk/core/agent";
import type { IDL } from "@icp-sdk/core/candid";
import type { Principal } from "@icp-sdk/core/principal";

export interface Account {
  owner: [] | [Principal];
  subaccount: [] | [Uint8Array | number[]];
}
/**
 * Generated from IC repo commit 206b61a (2025-09-25 tags: release-2025-09-25_09-52-base) 'rs/nns/governance/canister/governance.did' by import-candid
 */
export interface AccountIdentifier {
  hash: Uint8Array | number[];
}
export type Action =
  | { RegisterKnownNeuron: KnownNeuron }
  | { FulfillSubnetRentalRequest: FulfillSubnetRentalRequest }
  | { ManageNeuron: ManageNeuron }
  | { UpdateCanisterSettings: UpdateCanisterSettings }
  | { InstallCode: InstallCode }
  | { DeregisterKnownNeuron: DeregisterKnownNeuron }
  | { StopOrStartCanister: StopOrStartCanister }
  | { CreateServiceNervousSystem: CreateServiceNervousSystem }
  | { ExecuteNnsFunction: ExecuteNnsFunction }
  | { RewardNodeProvider: RewardNodeProvider }
  | { OpenSnsTokenSwap: OpenSnsTokenSwap }
  | { SetSnsTokenSwapOpenTimeWindow: SetSnsTokenSwapOpenTimeWindow }
  | { SetDefaultFollowees: SetDefaultFollowees }
  | { RewardNodeProviders: RewardNodeProviders }
  | { ManageNetworkEconomics: NetworkEconomics }
  | { ApproveGenesisKyc: Principals }
  | { AddOrRemoveNodeProvider: AddOrRemoveNodeProvider }
  | { Motion: Motion };
export interface AddHotKey {
  new_hot_key: [] | [Principal];
}
export interface AddOrRemoveNodeProvider {
  change: [] | [Change];
}
export interface Amount {
  e8s: bigint;
}
export interface ApproveGenesisKyc {
  principals: Array<Principal>;
}
export interface Ballot {
  vote: number;
  voting_power: bigint;
}
export interface BallotInfo {
  vote: number;
  proposal_id: [] | [ProposalId];
}
export type By =
  | { NeuronIdOrSubaccount: {} }
  | { MemoAndController: ClaimOrRefreshNeuronFromAccount }
  | { Memo: bigint };
export interface Canister {
  id: [] | [Principal];
}
export interface CanisterSettings {
  freezing_threshold: [] | [bigint];
  wasm_memory_threshold: [] | [bigint];
  controllers: [] | [Controllers];
  log_visibility: [] | [number];
  wasm_memory_limit: [] | [bigint];
  memory_allocation: [] | [bigint];
  compute_allocation: [] | [bigint];
}
export interface CanisterStatusResultV2 {
  status: [] | [number];
  freezing_threshold: [] | [bigint];
  controllers: Array<Principal>;
  memory_size: [] | [bigint];
  cycles: [] | [bigint];
  idle_cycles_burned_per_day: [] | [bigint];
  module_hash: Uint8Array | number[];
}
export interface CanisterSummary {
  status: [] | [CanisterStatusResultV2];
  canister_id: [] | [Principal];
}
export type Change = { ToRemove: NodeProvider } | { ToAdd: NodeProvider };
export interface ChangeAutoStakeMaturity {
  requested_setting_for_auto_stake_maturity: boolean;
}
export interface ClaimOrRefresh {
  by: [] | [By];
}
export interface ClaimOrRefreshNeuronFromAccount {
  controller: [] | [Principal];
  memo: bigint;
}
export interface ClaimOrRefreshNeuronFromAccountResponse {
  result: [] | [Result_1];
}
export interface ClaimOrRefreshResponse {
  refreshed_neuron_id: [] | [NeuronId];
}
/**
 * KEEP THIS IN SYNC WITH ManageNeuronCommandRequest!
 */
export type Command =
  | { Spawn: Spawn }
  | { Split: Split }
  | { Follow: Follow }
  | { DisburseMaturity: DisburseMaturity }
  | { RefreshVotingPower: RefreshVotingPower }
  | { ClaimOrRefresh: ClaimOrRefresh }
  | { Configure: Configure }
  | { RegisterVote: RegisterVote }
  | { Merge: Merge }
  | { DisburseToNeuron: DisburseToNeuron }
  | { SetFollowing: SetFollowing }
  | { MakeProposal: Proposal }
  | { StakeMaturity: StakeMaturity }
  | { MergeMaturity: MergeMaturity }
  | { Disburse: Disburse };
export type Command_1 =
  | { Error: GovernanceError }
  | { Spawn: SpawnResponse }
  | { Split: SpawnResponse }
  | { Follow: {} }
  | { DisburseMaturity: DisburseMaturityResponse }
  | { RefreshVotingPower: RefreshVotingPowerResponse }
  | { ClaimOrRefresh: ClaimOrRefreshResponse }
  | { Configure: {} }
  | { RegisterVote: {} }
  | { Merge: MergeResponse }
  | { DisburseToNeuron: SpawnResponse }
  | { SetFollowing: SetFollowingResponse }
  | { MakeProposal: MakeProposalResponse }
  | { StakeMaturity: StakeMaturityResponse }
  | { MergeMaturity: MergeMaturityResponse }
  | { Disburse: DisburseResponse };
export type Command_2 =
  | { Spawn: NeuronId }
  | { Split: Split }
  | { Configure: Configure }
  | { Merge: Merge }
  | { DisburseToNeuron: DisburseToNeuron }
  | { SyncCommand: {} }
  | { ClaimOrRefreshNeuron: ClaimOrRefresh }
  | { MergeMaturity: MergeMaturity }
  | { Disburse: Disburse };
export interface Committed {
  total_direct_contribution_icp_e8s: [] | [bigint];
  total_neurons_fund_contribution_icp_e8s: [] | [bigint];
  sns_governance_canister_id: [] | [Principal];
}
export interface Committed_1 {
  total_direct_participation_icp_e8s: [] | [bigint];
  total_neurons_fund_participation_icp_e8s: [] | [bigint];
  sns_governance_canister_id: [] | [Principal];
}
export interface Configure {
  operation: [] | [Operation];
}
export interface Controllers {
  controllers: Array<Principal>;
}
export interface Countries {
  iso_codes: Array<string>;
}
export interface CreateServiceNervousSystem {
  url: [] | [string];
  governance_parameters: [] | [GovernanceParameters];
  fallback_controller_principal_ids: Array<Principal>;
  logo: [] | [Image];
  name: [] | [string];
  ledger_parameters: [] | [LedgerParameters];
  description: [] | [string];
  dapp_canisters: Array<Canister>;
  swap_parameters: [] | [SwapParameters];
  initial_token_distribution: [] | [InitialTokenDistribution];
}
export interface DateRangeFilter {
  start_timestamp_seconds: [] | [bigint];
  end_timestamp_seconds: [] | [bigint];
}
export interface Decimal {
  human_readable: [] | [string];
}
export interface DeregisterKnownNeuron {
  id: [] | [NeuronId];
}
export interface DerivedProposalInformation {
  swap_background_information: [] | [SwapBackgroundInformation];
}
export interface DeveloperDistribution {
  developer_neurons: Array<NeuronDistribution>;
}
export interface Disburse {
  to_account: [] | [AccountIdentifier];
  amount: [] | [Amount];
}
export interface DisburseMaturity {
  to_account_identifier: [] | [AccountIdentifier];
  to_account: [] | [Account];
  percentage_to_disburse: number;
}
export interface DisburseMaturityResponse {
  amount_disbursed_e8s: [] | [bigint];
}
export interface DisburseResponse {
  transfer_block_height: bigint;
}
export interface DisburseToNeuron {
  dissolve_delay_seconds: bigint;
  kyc_verified: boolean;
  amount_e8s: bigint;
  new_controller: [] | [Principal];
  nonce: bigint;
}
export type DissolveState =
  | { DissolveDelaySeconds: bigint }
  | { WhenDissolvedTimestampSeconds: bigint };
export interface Duration {
  seconds: [] | [bigint];
}
export interface ExecuteNnsFunction {
  nns_function: number;
  payload: Uint8Array | number[];
}
export interface Follow {
  topic: number;
  followees: Array<NeuronId>;
}
export interface Followees {
  followees: Array<NeuronId>;
}
export interface FolloweesForTopic {
  topic: [] | [number];
  followees: [] | [Array<NeuronId>];
}
/**
 * Creates a rented subnet from a rental request (in the Subnet Rental
 * canister).
 */
export interface FulfillSubnetRentalRequest {
  /**
   * Identifies which rental request to fulfill.
   *
   * (Identifying the rental request by user works, because a user can have at
   * most one rental request in the Subnet Rental canister).
   */
  user: [] | [Principal];
  /**
   * What software the nodes will run.
   *
   * This must be approved by a prior proposal to bless an IC OS version.
   *
   * This is a FULL git commit ID in the ic repo. (Therefore, it must be a 40
   * character hexidecimal string, not an abbreviated git commit ID.)
   *
   * One way to find a suitable value is with the following command:
   *
   * ic-admin \
   * get-subnet 0 \
   * --nns-urls https://nns.ic0.app \
   * | grep replica_version_id
   *
   * Where to obtain a recent version of ic-admin:
   *
   * https://github.com/dfinity/ic/releases/latest
   */
  replica_version_id: [] | [string];
  /**
   * Which nodes will be members of the subnet.
   */
  node_ids: [] | [Array<Principal>];
}
export interface GetNeuronsFundAuditInfoRequest {
  nns_proposal_id: [] | [ProposalId];
}
export interface GetNeuronsFundAuditInfoResponse {
  result: [] | [Result_6];
}
export interface GlobalTimeOfDay {
  seconds_after_utc_midnight: [] | [bigint];
}
export interface Governance {
  default_followees: Array<[number, Followees]>;
  most_recent_monthly_node_provider_rewards: [] | [MonthlyNodeProviderRewards];
  maturity_modulation_last_updated_at_timestamp_seconds: [] | [bigint];
  wait_for_quiet_threshold_seconds: bigint;
  metrics: [] | [GovernanceCachedMetrics];
  neuron_management_voting_period_seconds: [] | [bigint];
  node_providers: Array<NodeProvider>;
  cached_daily_maturity_modulation_basis_points: [] | [number];
  economics: [] | [NetworkEconomics];
  restore_aging_summary: [] | [RestoreAgingSummary];
  spawning_neurons: [] | [boolean];
  latest_reward_event: [] | [RewardEvent];
  to_claim_transfers: Array<NeuronStakeTransfer>;
  short_voting_period_seconds: bigint;
  proposals: Array<[bigint, ProposalData]>;
  xdr_conversion_rate: [] | [XdrConversionRate];
  in_flight_commands: Array<[bigint, NeuronInFlightCommand]>;
  neurons: Array<[bigint, Neuron]>;
  genesis_timestamp_seconds: bigint;
}
export interface GovernanceCachedMetrics {
  total_maturity_e8s_equivalent: bigint;
  not_dissolving_neurons_e8s_buckets: Array<[bigint, number]>;
  dissolving_neurons_staked_maturity_e8s_equivalent_sum: bigint;
  garbage_collectable_neurons_count: bigint;
  dissolving_neurons_staked_maturity_e8s_equivalent_buckets: Array<
    [bigint, number]
  >;
  neurons_with_invalid_stake_count: bigint;
  not_dissolving_neurons_count_buckets: Array<[bigint, bigint]>;
  ect_neuron_count: bigint;
  total_supply_icp: bigint;
  neurons_with_less_than_6_months_dissolve_delay_count: bigint;
  dissolved_neurons_count: bigint;
  community_fund_total_maturity_e8s_equivalent: bigint;
  total_staked_e8s_seed: bigint;
  total_staked_maturity_e8s_equivalent_ect: bigint;
  total_staked_e8s: bigint;
  fully_lost_voting_power_neuron_subset_metrics: [] | [NeuronSubsetMetrics];
  not_dissolving_neurons_count: bigint;
  total_locked_e8s: bigint;
  neurons_fund_total_active_neurons: bigint;
  total_voting_power_non_self_authenticating_controller: [] | [bigint];
  total_staked_maturity_e8s_equivalent: bigint;
  not_dissolving_neurons_e8s_buckets_ect: Array<[bigint, number]>;
  spawning_neurons_count: bigint;
  declining_voting_power_neuron_subset_metrics: [] | [NeuronSubsetMetrics];
  total_staked_e8s_ect: bigint;
  not_dissolving_neurons_staked_maturity_e8s_equivalent_sum: bigint;
  dissolved_neurons_e8s: bigint;
  total_staked_e8s_non_self_authenticating_controller: [] | [bigint];
  dissolving_neurons_e8s_buckets_seed: Array<[bigint, number]>;
  neurons_with_less_than_6_months_dissolve_delay_e8s: bigint;
  not_dissolving_neurons_staked_maturity_e8s_equivalent_buckets: Array<
    [bigint, number]
  >;
  dissolving_neurons_count_buckets: Array<[bigint, bigint]>;
  dissolving_neurons_e8s_buckets_ect: Array<[bigint, number]>;
  non_self_authenticating_controller_neuron_subset_metrics:
    | []
    | [NeuronSubsetMetrics];
  dissolving_neurons_count: bigint;
  dissolving_neurons_e8s_buckets: Array<[bigint, number]>;
  total_staked_maturity_e8s_equivalent_seed: bigint;
  community_fund_total_staked_e8s: bigint;
  not_dissolving_neurons_e8s_buckets_seed: Array<[bigint, number]>;
  public_neuron_subset_metrics: [] | [NeuronSubsetMetrics];
  timestamp_seconds: bigint;
  seed_neuron_count: bigint;
}
export interface GovernanceError {
  error_message: string;
  error_type: number;
}
export interface GovernanceParameters {
  neuron_maximum_dissolve_delay_bonus: [] | [Percentage];
  neuron_maximum_age_for_age_bonus: [] | [Duration];
  neuron_maximum_dissolve_delay: [] | [Duration];
  neuron_minimum_dissolve_delay_to_vote: [] | [Duration];
  neuron_maximum_age_bonus: [] | [Percentage];
  neuron_minimum_stake: [] | [Tokens];
  proposal_wait_for_quiet_deadline_increase: [] | [Duration];
  proposal_initial_voting_period: [] | [Duration];
  proposal_rejection_fee: [] | [Tokens];
  voting_reward_parameters: [] | [VotingRewardParameters];
}
export interface IdealMatchedParticipationFunction {
  serialized_representation: [] | [string];
}
export interface Image {
  base64_encoding: [] | [string];
}
export interface IncreaseDissolveDelay {
  additional_dissolve_delay_seconds: number;
}
export interface InitialTokenDistribution {
  treasury_distribution: [] | [SwapDistribution];
  developer_distribution: [] | [DeveloperDistribution];
  swap_distribution: [] | [SwapDistribution];
}
export interface InstallCode {
  skip_stopping_before_installing: [] | [boolean];
  wasm_module_hash: [] | [Uint8Array | number[]];
  canister_id: [] | [Principal];
  arg_hash: [] | [Uint8Array | number[]];
  install_mode: [] | [number];
}
export interface InstallCodeRequest {
  arg: [] | [Uint8Array | number[]];
  wasm_module: [] | [Uint8Array | number[]];
  skip_stopping_before_installing: [] | [boolean];
  canister_id: [] | [Principal];
  install_mode: [] | [number];
}
export interface KnownNeuron {
  id: [] | [NeuronId];
  known_neuron_data: [] | [KnownNeuronData];
}
export interface KnownNeuronData {
  name: string;
  description: [] | [string];
  links: [] | [Array<string>];
}
export interface LedgerParameters {
  transaction_fee: [] | [Tokens];
  token_symbol: [] | [string];
  token_logo: [] | [Image];
  token_name: [] | [string];
}
export interface ListKnownNeuronsResponse {
  known_neurons: Array<KnownNeuron>;
}
/**
 * Parameters of the list_neurons method.
 */
export interface ListNeurons {
  page_size: [] | [bigint];
  /**
   * When a public neuron is a member of the result set, include it in the
   * full_neurons field (of ListNeuronsResponse). This does not affect which
   * neurons are part of the result set.
   */
  include_public_neurons_in_full_neurons: [] | [boolean];
  /**
   * These fields select neurons to be in the result set.
   */
  neuron_ids: BigUint64Array | bigint[];
  page_number: [] | [bigint];
  /**
   * Only has an effect when include_neurons_readable_by_caller.
   */
  include_empty_neurons_readable_by_caller: [] | [boolean];
  neuron_subaccounts: [] | [Array<NeuronSubaccount>];
  include_neurons_readable_by_caller: boolean;
}
/**
 * Output of the list_neurons method.
 */
export interface ListNeuronsResponse {
  /**
   * Per the NeuronInfo type, this is a redacted view of the neurons in the
   * result set consisting of information that require no special privileges to
   * view.
   */
  neuron_infos: Array<[bigint, NeuronInfo]>;
  /**
   * If the caller has the necessary special privileges (or the neuron is
   * public, and the request sets include_public_neurons_in_full_neurons to
   * true), then all the information about the neurons in the result set is made
   * available here.
   */
  full_neurons: Array<Neuron>;
  total_pages_available: [] | [bigint];
}
export interface ListNodeProviderRewardsRequest {
  date_filter: [] | [DateRangeFilter];
}
export interface ListNodeProviderRewardsResponse {
  rewards: Array<MonthlyNodeProviderRewards>;
}
export interface ListNodeProvidersResponse {
  node_providers: Array<NodeProvider>;
}
export interface ListProposalInfo {
  include_reward_status: Int32Array | number[];
  omit_large_fields: [] | [boolean];
  before_proposal: [] | [ProposalId];
  limit: number;
  exclude_topic: Int32Array | number[];
  include_all_manage_neuron_proposals: [] | [boolean];
  include_status: Int32Array | number[];
}
export interface ListProposalInfoResponse {
  proposal_info: Array<ProposalInfo>;
}
export interface MakeProposalRequest {
  url: string;
  title: [] | [string];
  action: [] | [ProposalActionRequest];
  summary: string;
}
export interface MakeProposalResponse {
  message: [] | [string];
  proposal_id: [] | [ProposalId];
}
/**
 * Not to be confused with ManageNeuronRequest. (Yes, this is very structurally
 * similar to that, but not actually exactly equivalent.)
 */
export interface ManageNeuron {
  id: [] | [NeuronId];
  command: [] | [Command];
  neuron_id_or_subaccount: [] | [NeuronIdOrSubaccount];
}
/**
 * KEEP THIS IN SYNC WITH COMMAND!
 */
export type ManageNeuronCommandRequest =
  | { Spawn: Spawn }
  | { Split: Split }
  | { Follow: Follow }
  | { DisburseMaturity: DisburseMaturity }
  | { RefreshVotingPower: RefreshVotingPower }
  | { ClaimOrRefresh: ClaimOrRefresh }
  | { Configure: Configure }
  | { RegisterVote: RegisterVote }
  | { Merge: Merge }
  | { DisburseToNeuron: DisburseToNeuron }
  | { SetFollowing: SetFollowing }
  | { MakeProposal: MakeProposalRequest }
  | { StakeMaturity: StakeMaturity }
  | { MergeMaturity: MergeMaturity }
  | { Disburse: Disburse };
/**
 * Parameters of the manage_neuron method.
 */
export interface ManageNeuronRequest {
  /**
   * Deprecated. Use neuron_id_or_subaccount instead.
   */
  id: [] | [NeuronId];
  /**
   * What operation to perform on the neuron.
   */
  command: [] | [ManageNeuronCommandRequest];
  /**
   * Which neuron to operate on.
   */
  neuron_id_or_subaccount: [] | [NeuronIdOrSubaccount];
}
/**
 * Output of the manage_neuron method.
 */
export interface ManageNeuronResponse {
  /**
   * Corresponds to the command field in ManageNeuronRequest, which determines
   * what operation was performed.
   */
  command: [] | [Command_1];
}
export interface MaturityDisbursement {
  account_identifier_to_disburse_to: [] | [AccountIdentifier];
  timestamp_of_disbursement_seconds: [] | [bigint];
  amount_e8s: [] | [bigint];
  account_to_disburse_to: [] | [Account];
  finalize_disbursement_timestamp_seconds: [] | [bigint];
}
export interface Merge {
  source_neuron_id: [] | [NeuronId];
}
export interface MergeMaturity {
  percentage_to_merge: number;
}
export interface MergeMaturityResponse {
  merged_maturity_e8s: bigint;
  new_stake_e8s: bigint;
}
export interface MergeResponse {
  target_neuron: [] | [Neuron];
  source_neuron: [] | [Neuron];
  target_neuron_info: [] | [NeuronInfo];
  source_neuron_info: [] | [NeuronInfo];
}
export interface MonthlyNodeProviderRewards {
  minimum_xdr_permyriad_per_icp: [] | [bigint];
  registry_version: [] | [bigint];
  node_providers: Array<NodeProvider>;
  timestamp: bigint;
  rewards: Array<RewardNodeProvider>;
  xdr_conversion_rate: [] | [XdrConversionRate];
  maximum_node_provider_rewards_e8s: [] | [bigint];
}
export interface Motion {
  motion_text: string;
}
export interface NetworkEconomics {
  neuron_minimum_stake_e8s: bigint;
  /**
   * Parameters that affect the voting power of neurons.
   */
  voting_power_economics: [] | [VotingPowerEconomics];
  max_proposals_to_keep_per_topic: number;
  neuron_management_fee_per_proposal_e8s: bigint;
  reject_cost_e8s: bigint;
  transaction_fee_e8s: bigint;
  neuron_spawn_dissolve_delay_seconds: bigint;
  minimum_icp_xdr_rate: bigint;
  maximum_node_provider_rewards_e8s: bigint;
  neurons_fund_economics: [] | [NeuronsFundEconomics];
}
export interface Neuron {
  id: [] | [NeuronId];
  staked_maturity_e8s_equivalent: [] | [bigint];
  controller: [] | [Principal];
  recent_ballots: Array<BallotInfo>;
  voting_power_refreshed_timestamp_seconds: [] | [bigint];
  kyc_verified: boolean;
  /**
   * The amount of "sway" this neuron can have if it refreshes its voting power
   * frequently enough.
   *
   * Unlike deciding_voting_power, this does NOT take refreshing into account.
   * Rather, this only takes three factors into account:
   *
   * 1. (Net) staked amount - This is the "base" of a neuron's voting power.
   * This primarily consists of the neuron's ICP balance.
   *
   * 2. Age - Neurons with more age have more voting power (all else being
   * equal).
   *
   * 3. Dissolve delay - Neurons with longer dissolve delay have more voting
   * power (all else being equal). Neurons with a dissolve delay of less
   * than six months are not eligible to vote. Therefore, such neurons
   * are considered to have 0 voting power.
   *
   * Per NNS policy, this is opt. Nevertheless, it will never be null.
   */
  potential_voting_power: [] | [bigint];
  neuron_type: [] | [number];
  not_for_profit: boolean;
  maturity_e8s_equivalent: bigint;
  /**
   * The amount of "sway" this neuron has when voting on proposals.
   *
   * When a proposal is created, each eligible neuron gets a "blank" ballot. The
   * amount of voting power in that ballot is set to the neuron's deciding
   * voting power at the time of proposal creation. There are two ways that a
   * proposal can become decided:
   *
   * 1. Early: Either more than half of the total voting power in the ballots
   * votes in favor (then the proposal is approved), or at least half of the
   * votal voting power in the ballots votes against (then, the proposal is
   * rejected).
   *
   * 2. The proposal's voting deadline is reached. At that point, if there is
   * more voting power in favor than against, and at least 3% of the total
   * voting power voted in favor, then the proposal is approved. Otherwise, it
   * is rejected.
   *
   * If a neuron regularly refreshes its voting power, this has the same value
   * as potential_voting_power. Actions that cause a refresh are as follows:
   *
   * 1. voting directly (not via following)
   * 2. set following
   * 3. refresh voting power
   *
   * (All of these actions are performed via the manage_neuron method.)
   *
   * However, if a neuron has not refreshed in a "long" time, this will be less
   * than potential voting power. See VotingPowerEconomics. As a further result
   * of less deciding voting power, not only does it have less influence on the
   * outcome of proposals, the neuron receives less voting rewards (when it
   * votes indirectly via following).
   *
   * For details, see https://dashboard.internetcomputer.org/proposal/132411.
   *
   * Per NNS policy, this is opt. Nevertheless, it will never be null.
   */
  deciding_voting_power: [] | [bigint];
  cached_neuron_stake_e8s: bigint;
  created_timestamp_seconds: bigint;
  auto_stake_maturity: [] | [boolean];
  aging_since_timestamp_seconds: bigint;
  hot_keys: Array<Principal>;
  account: Uint8Array | number[];
  joined_community_fund_timestamp_seconds: [] | [bigint];
  /**
   * The maturity disbursements in progress, i.e. the disbursements that are initiated but not
   * finalized. The finalization happens 7 days after the disbursement is initiated.
   */
  maturity_disbursements_in_progress: [] | [Array<MaturityDisbursement>];
  dissolve_state: [] | [DissolveState];
  followees: Array<[number, Followees]>;
  neuron_fees_e8s: bigint;
  visibility: [] | [number];
  transfer: [] | [NeuronStakeTransfer];
  known_neuron_data: [] | [KnownNeuronData];
  spawn_at_timestamp_seconds: [] | [bigint];
}
export interface NeuronBasketConstructionParameters {
  dissolve_delay_interval: [] | [Duration];
  count: [] | [bigint];
}
export interface NeuronBasketConstructionParameters_1 {
  dissolve_delay_interval_seconds: bigint;
  count: bigint;
}
export interface NeuronDistribution {
  controller: [] | [Principal];
  dissolve_delay: [] | [Duration];
  memo: [] | [bigint];
  vesting_period: [] | [Duration];
  stake: [] | [Tokens];
}
export interface NeuronId {
  id: bigint;
}
export type NeuronIdOrSubaccount =
  | { Subaccount: Uint8Array | number[] }
  | { NeuronId: NeuronId };
export interface NeuronInFlightCommand {
  command: [] | [Command_2];
  timestamp: bigint;
}
/**
 * A limit view of Neuron that allows some aspects of all neurons to be read by
 * anyone (i.e. without having to be the neuron's controller nor one of its
 * hotkeys).
 *
 * As such, the meaning of each field in this type is generally the same as the
 * one of the same (or at least similar) name in Neuron.
 */
export interface NeuronInfo {
  dissolve_delay_seconds: bigint;
  recent_ballots: Array<BallotInfo>;
  voting_power_refreshed_timestamp_seconds: [] | [bigint];
  potential_voting_power: [] | [bigint];
  neuron_type: [] | [number];
  deciding_voting_power: [] | [bigint];
  created_timestamp_seconds: bigint;
  state: number;
  /**
   * The amount of ICP (and staked maturity) locked in this neuron.
   *
   * This is the foundation of the neuron's voting power.
   *
   * cached_neuron_stake_e8s - neuron_fees_e8s + staked_maturity_e8s_equivalent
   */
  stake_e8s: bigint;
  joined_community_fund_timestamp_seconds: [] | [bigint];
  retrieved_at_timestamp_seconds: bigint;
  visibility: [] | [number];
  known_neuron_data: [] | [KnownNeuronData];
  /**
   * Deprecated. Use either deciding_voting_power or potential_voting_power
   * instead. Has the same value as deciding_voting_power.
   *
   * Previously, if a neuron had < 6 months dissolve delay (making it ineligible
   * to vote), this would not get set to 0 (zero). That was pretty confusing.
   * Now that this is set to deciding_voting_power, this actually does get
   * zeroed out.
   */
  voting_power: bigint;
  age_seconds: bigint;
}
export interface NeuronStakeTransfer {
  to_subaccount: Uint8Array | number[];
  neuron_stake_e8s: bigint;
  from: [] | [Principal];
  memo: bigint;
  from_subaccount: Uint8Array | number[];
  transfer_timestamp: bigint;
  block_height: bigint;
}
export interface NeuronSubaccount {
  subaccount: Uint8Array | number[];
}
export interface NeuronSubsetMetrics {
  total_maturity_e8s_equivalent: [] | [bigint];
  maturity_e8s_equivalent_buckets: Array<[bigint, bigint]>;
  voting_power_buckets: Array<[bigint, bigint]>;
  total_staked_e8s: [] | [bigint];
  count: [] | [bigint];
  deciding_voting_power_buckets: Array<[bigint, bigint]>;
  total_staked_maturity_e8s_equivalent: [] | [bigint];
  total_potential_voting_power: [] | [bigint];
  total_deciding_voting_power: [] | [bigint];
  staked_maturity_e8s_equivalent_buckets: Array<[bigint, bigint]>;
  staked_e8s_buckets: Array<[bigint, bigint]>;
  total_voting_power: [] | [bigint];
  potential_voting_power_buckets: Array<[bigint, bigint]>;
  count_buckets: Array<[bigint, bigint]>;
}
export interface NeuronsFundAuditInfo {
  final_neurons_fund_participation: [] | [NeuronsFundParticipation];
  initial_neurons_fund_participation: [] | [NeuronsFundParticipation];
  neurons_fund_refunds: [] | [NeuronsFundSnapshot];
}
export interface NeuronsFundData {
  final_neurons_fund_participation: [] | [NeuronsFundParticipation];
  initial_neurons_fund_participation: [] | [NeuronsFundParticipation];
  neurons_fund_refunds: [] | [NeuronsFundSnapshot];
}
export interface NeuronsFundEconomics {
  maximum_icp_xdr_rate: [] | [Percentage];
  neurons_fund_matched_funding_curve_coefficients:
    | []
    | [NeuronsFundMatchedFundingCurveCoefficients];
  max_theoretical_neurons_fund_participation_amount_xdr: [] | [Decimal];
  minimum_icp_xdr_rate: [] | [Percentage];
}
export interface NeuronsFundMatchedFundingCurveCoefficients {
  contribution_threshold_xdr: [] | [Decimal];
  one_third_participation_milestone_xdr: [] | [Decimal];
  full_participation_milestone_xdr: [] | [Decimal];
}
export interface NeuronsFundNeuron {
  controller: [] | [Principal];
  hotkeys: [] | [Principals];
  is_capped: [] | [boolean];
  nns_neuron_id: [] | [bigint];
  amount_icp_e8s: [] | [bigint];
}
export interface NeuronsFundNeuronPortion {
  controller: [] | [Principal];
  hotkeys: Array<Principal>;
  is_capped: [] | [boolean];
  maturity_equivalent_icp_e8s: [] | [bigint];
  nns_neuron_id: [] | [NeuronId];
  amount_icp_e8s: [] | [bigint];
}
export interface NeuronsFundParticipation {
  total_maturity_equivalent_icp_e8s: [] | [bigint];
  intended_neurons_fund_participation_icp_e8s: [] | [bigint];
  direct_participation_icp_e8s: [] | [bigint];
  swap_participation_limits: [] | [SwapParticipationLimits];
  max_neurons_fund_swap_participation_icp_e8s: [] | [bigint];
  neurons_fund_reserves: [] | [NeuronsFundSnapshot];
  ideal_matched_participation_function:
    | []
    | [IdealMatchedParticipationFunction];
  allocated_neurons_fund_participation_icp_e8s: [] | [bigint];
}
export interface NeuronsFundSnapshot {
  neurons_fund_neuron_portions: Array<NeuronsFundNeuronPortion>;
}
export interface NodeProvider {
  id: [] | [Principal];
  reward_account: [] | [AccountIdentifier];
}
export interface Ok {
  neurons_fund_audit_info: [] | [NeuronsFundAuditInfo];
}
export interface Ok_1 {
  neurons_fund_neuron_portions: Array<NeuronsFundNeuron>;
}
export interface OpenSnsTokenSwap {
  community_fund_investment_e8s: [] | [bigint];
  target_swap_canister_id: [] | [Principal];
  params: [] | [Params];
}
export type Operation =
  | { RemoveHotKey: RemoveHotKey }
  | { AddHotKey: AddHotKey }
  | { ChangeAutoStakeMaturity: ChangeAutoStakeMaturity }
  | { StopDissolving: {} }
  | { StartDissolving: {} }
  | { IncreaseDissolveDelay: IncreaseDissolveDelay }
  | { SetVisibility: SetVisibility }
  | { JoinCommunityFund: {} }
  | { LeaveCommunityFund: {} }
  | { SetDissolveTimestamp: SetDissolveTimestamp };
export interface Params {
  min_participant_icp_e8s: bigint;
  neuron_basket_construction_parameters:
    | []
    | [NeuronBasketConstructionParameters_1];
  max_icp_e8s: bigint;
  swap_due_timestamp_seconds: bigint;
  min_participants: number;
  sns_token_e8s: bigint;
  sale_delay_seconds: [] | [bigint];
  max_participant_icp_e8s: bigint;
  min_direct_participation_icp_e8s: [] | [bigint];
  min_icp_e8s: bigint;
  max_direct_participation_icp_e8s: [] | [bigint];
}
export interface Percentage {
  basis_points: [] | [bigint];
}
export interface Principals {
  principals: Array<Principal>;
}
export interface Proposal {
  url: string;
  title: [] | [string];
  action: [] | [Action];
  summary: string;
}
export type ProposalActionRequest =
  | { RegisterKnownNeuron: KnownNeuron }
  | { FulfillSubnetRentalRequest: FulfillSubnetRentalRequest }
  | { ManageNeuron: ManageNeuronRequest }
  | { UpdateCanisterSettings: UpdateCanisterSettings }
  | { InstallCode: InstallCodeRequest }
  | { DeregisterKnownNeuron: DeregisterKnownNeuron }
  | { StopOrStartCanister: StopOrStartCanister }
  | { CreateServiceNervousSystem: CreateServiceNervousSystem }
  | { ExecuteNnsFunction: ExecuteNnsFunction }
  | { RewardNodeProvider: RewardNodeProvider }
  | { RewardNodeProviders: RewardNodeProviders }
  | { ManageNetworkEconomics: NetworkEconomics }
  | { ApproveGenesisKyc: Principals }
  | { AddOrRemoveNodeProvider: AddOrRemoveNodeProvider }
  | { Motion: Motion };
export interface ProposalData {
  id: [] | [ProposalId];
  topic: [] | [number];
  failure_reason: [] | [GovernanceError];
  ballots: Array<[bigint, Ballot]>;
  proposal_timestamp_seconds: bigint;
  reward_event_round: bigint;
  failed_timestamp_seconds: bigint;
  neurons_fund_data: [] | [NeuronsFundData];
  reject_cost_e8s: bigint;
  derived_proposal_information: [] | [DerivedProposalInformation];
  latest_tally: [] | [Tally];
  total_potential_voting_power: [] | [bigint];
  sns_token_swap_lifecycle: [] | [number];
  decided_timestamp_seconds: bigint;
  proposal: [] | [Proposal];
  proposer: [] | [NeuronId];
  wait_for_quiet_state: [] | [WaitForQuietState];
  executed_timestamp_seconds: bigint;
  original_total_community_fund_maturity_e8s_equivalent: [] | [bigint];
}
export interface ProposalId {
  id: bigint;
}
export interface ProposalInfo {
  id: [] | [ProposalId];
  status: number;
  topic: number;
  failure_reason: [] | [GovernanceError];
  ballots: Array<[bigint, Ballot]>;
  proposal_timestamp_seconds: bigint;
  reward_event_round: bigint;
  deadline_timestamp_seconds: [] | [bigint];
  failed_timestamp_seconds: bigint;
  reject_cost_e8s: bigint;
  derived_proposal_information: [] | [DerivedProposalInformation];
  latest_tally: [] | [Tally];
  total_potential_voting_power: [] | [bigint];
  reward_status: number;
  decided_timestamp_seconds: bigint;
  proposal: [] | [Proposal];
  proposer: [] | [NeuronId];
  executed_timestamp_seconds: bigint;
}
/**
 * This is one way for a neuron to make sure that its deciding_voting_power is
 * not less than its potential_voting_power. See the description of those fields
 * in Neuron.
 */
export type RefreshVotingPower = {};
export type RefreshVotingPowerResponse = {};
export interface RegisterVote {
  vote: number;
  proposal: [] | [ProposalId];
}
export interface RemoveHotKey {
  hot_key_to_remove: [] | [Principal];
}
export interface RestoreAgingNeuronGroup {
  count: [] | [bigint];
  previous_total_stake_e8s: [] | [bigint];
  current_total_stake_e8s: [] | [bigint];
  group_type: number;
}
export interface RestoreAgingSummary {
  groups: Array<RestoreAgingNeuronGroup>;
  timestamp_seconds: [] | [bigint];
}
export type Result = { Ok: null } | { Err: GovernanceError };
export type Result_1 = { Error: GovernanceError } | { NeuronId: NeuronId };
export type Result_10 = { Ok: Ok_1 } | { Err: GovernanceError };
export type Result_2 = { Ok: Neuron } | { Err: GovernanceError };
export type Result_3 =
  | { Ok: GovernanceCachedMetrics }
  | { Err: GovernanceError };
export type Result_4 =
  | { Ok: MonthlyNodeProviderRewards }
  | { Err: GovernanceError };
export type Result_5 = { Ok: NeuronInfo } | { Err: GovernanceError };
export type Result_6 = { Ok: Ok } | { Err: GovernanceError };
export type Result_7 = { Ok: NodeProvider } | { Err: GovernanceError };
export type Result_8 = { Committed: Committed } | { Aborted: {} };
export type Result_9 = { Committed: Committed_1 } | { Aborted: {} };
export interface RewardEvent {
  rounds_since_last_distribution: [] | [bigint];
  day_after_genesis: bigint;
  actual_timestamp_seconds: bigint;
  total_available_e8s_equivalent: bigint;
  latest_round_available_e8s_equivalent: [] | [bigint];
  distributed_e8s_equivalent: bigint;
  settled_proposals: Array<ProposalId>;
}
export type RewardMode =
  | { RewardToNeuron: RewardToNeuron }
  | { RewardToAccount: RewardToAccount };
export interface RewardNodeProvider {
  node_provider: [] | [NodeProvider];
  reward_mode: [] | [RewardMode];
  amount_e8s: bigint;
}
export interface RewardNodeProviders {
  use_registry_derived_rewards: [] | [boolean];
  rewards: Array<RewardNodeProvider>;
}
export interface RewardToAccount {
  to_account: [] | [AccountIdentifier];
}
export interface RewardToNeuron {
  dissolve_delay_seconds: bigint;
}
export interface SetDefaultFollowees {
  default_followees: Array<[number, Followees]>;
}
export interface SetDissolveTimestamp {
  dissolve_timestamp_seconds: bigint;
}
export interface SetFollowing {
  topic_following: [] | [Array<FolloweesForTopic>];
}
export type SetFollowingResponse = {};
export interface SetOpenTimeWindowRequest {
  open_time_window: [] | [TimeWindow];
}
export interface SetSnsTokenSwapOpenTimeWindow {
  request: [] | [SetOpenTimeWindowRequest];
  swap_canister_id: [] | [Principal];
}
export interface SetVisibility {
  visibility: [] | [number];
}
export interface SettleCommunityFundParticipation {
  result: [] | [Result_8];
  open_sns_token_swap_proposal_id: [] | [bigint];
}
export interface SettleNeuronsFundParticipationRequest {
  result: [] | [Result_9];
  nns_proposal_id: [] | [bigint];
}
export interface SettleNeuronsFundParticipationResponse {
  result: [] | [Result_10];
}
export interface Spawn {
  percentage_to_spawn: [] | [number];
  new_controller: [] | [Principal];
  nonce: [] | [bigint];
}
export interface SpawnResponse {
  created_neuron_id: [] | [NeuronId];
}
export interface Split {
  memo: [] | [bigint];
  amount_e8s: bigint;
}
export interface StakeMaturity {
  percentage_to_stake: [] | [number];
}
export interface StakeMaturityResponse {
  maturity_e8s: bigint;
  staked_maturity_e8s: bigint;
}
export interface StopOrStartCanister {
  action: [] | [number];
  canister_id: [] | [Principal];
}
export interface SwapBackgroundInformation {
  ledger_index_canister_summary: [] | [CanisterSummary];
  fallback_controller_principal_ids: Array<Principal>;
  ledger_archive_canister_summaries: Array<CanisterSummary>;
  ledger_canister_summary: [] | [CanisterSummary];
  swap_canister_summary: [] | [CanisterSummary];
  governance_canister_summary: [] | [CanisterSummary];
  root_canister_summary: [] | [CanisterSummary];
  dapp_canister_summaries: Array<CanisterSummary>;
}
export interface SwapDistribution {
  total: [] | [Tokens];
}
export interface SwapParameters {
  minimum_participants: [] | [bigint];
  neurons_fund_participation: [] | [boolean];
  duration: [] | [Duration];
  neuron_basket_construction_parameters:
    | []
    | [NeuronBasketConstructionParameters];
  confirmation_text: [] | [string];
  maximum_participant_icp: [] | [Tokens];
  minimum_icp: [] | [Tokens];
  minimum_direct_participation_icp: [] | [Tokens];
  minimum_participant_icp: [] | [Tokens];
  start_time: [] | [GlobalTimeOfDay];
  maximum_direct_participation_icp: [] | [Tokens];
  maximum_icp: [] | [Tokens];
  neurons_fund_investment_icp: [] | [Tokens];
  restricted_countries: [] | [Countries];
}
export interface SwapParticipationLimits {
  min_participant_icp_e8s: [] | [bigint];
  max_participant_icp_e8s: [] | [bigint];
  min_direct_participation_icp_e8s: [] | [bigint];
  max_direct_participation_icp_e8s: [] | [bigint];
}
export interface Tally {
  no: bigint;
  yes: bigint;
  total: bigint;
  timestamp_seconds: bigint;
}
export interface TimeWindow {
  start_timestamp_seconds: bigint;
  end_timestamp_seconds: bigint;
}
export interface Tokens {
  e8s: [] | [bigint];
}
export interface UpdateCanisterSettings {
  canister_id: [] | [Principal];
  settings: [] | [CanisterSettings];
}
export interface UpdateNodeProvider {
  reward_account: [] | [AccountIdentifier];
}
/**
 * Parameters that affect the voting power of neurons.
 */
export interface VotingPowerEconomics {
  /**
   * If a neuron has not "refreshed" its voting power after this amount of time,
   * its deciding voting power starts decreasing linearly. See also
   * clear_following_after_seconds.
   *
   * For explanation of what "refresh" means in this context, see
   * https://dashboard.internetcomputer.org/proposal/132411
   *
   * Initially, set to 0.5 years. (The nominal length of a year is 365.25 days).
   */
  start_reducing_voting_power_after_seconds: [] | [bigint];
  /**
   * The minimum dissolve delay a neuron must have in order to be eligible to vote.
   *
   * Neurons with a dissolve delay lower than this threshold will not have
   * voting power, even if they are otherwise active.
   *
   * This value is an essential part of the staking mechanism, promoting
   * long-term alignment with the network's governance.
   */
  neuron_minimum_dissolve_delay_to_vote_seconds: [] | [bigint];
  /**
   * After a neuron has experienced voting power reduction for this amount of
   * time, a couple of things happen:
   *
   * 1. Deciding voting power reaches 0.
   *
   * 2. Its following on topics other than NeuronManagement are cleared.
   *
   * Initially, set to 1/12 years.
   */
  clear_following_after_seconds: [] | [bigint];
}
export interface VotingRewardParameters {
  reward_rate_transition_duration: [] | [Duration];
  initial_reward_rate: [] | [Percentage];
  final_reward_rate: [] | [Percentage];
}
export interface WaitForQuietState {
  current_deadline_timestamp_seconds: bigint;
}
export interface XdrConversionRate {
  xdr_permyriad_per_icp: [] | [bigint];
  timestamp_seconds: [] | [bigint];
}
export interface _SERVICE {
  claim_gtc_neurons: ActorMethod<[Principal, Array<NeuronId>], Result>;
  claim_or_refresh_neuron_from_account: ActorMethod<
    [ClaimOrRefreshNeuronFromAccount],
    ClaimOrRefreshNeuronFromAccountResponse
  >;
  get_build_metadata: ActorMethod<[], string>;
  get_full_neuron: ActorMethod<[bigint], Result_2>;
  get_full_neuron_by_id_or_subaccount: ActorMethod<
    [NeuronIdOrSubaccount],
    Result_2
  >;
  get_latest_reward_event: ActorMethod<[], RewardEvent>;
  get_metrics: ActorMethod<[], Result_3>;
  get_monthly_node_provider_rewards: ActorMethod<[], Result_4>;
  get_most_recent_monthly_node_provider_rewards: ActorMethod<
    [],
    [] | [MonthlyNodeProviderRewards]
  >;
  get_network_economics_parameters: ActorMethod<[], NetworkEconomics>;
  get_neuron_ids: ActorMethod<[], BigUint64Array | bigint[]>;
  get_neuron_info: ActorMethod<[bigint], Result_5>;
  get_neuron_info_by_id_or_subaccount: ActorMethod<
    [NeuronIdOrSubaccount],
    Result_5
  >;
  get_neurons_fund_audit_info: ActorMethod<
    [GetNeuronsFundAuditInfoRequest],
    GetNeuronsFundAuditInfoResponse
  >;
  get_node_provider_by_caller: ActorMethod<[null], Result_7>;
  get_pending_proposals: ActorMethod<[], Array<ProposalInfo>>;
  get_proposal_info: ActorMethod<[bigint], [] | [ProposalInfo]>;
  get_restore_aging_summary: ActorMethod<[], RestoreAgingSummary>;
  list_known_neurons: ActorMethod<[], ListKnownNeuronsResponse>;
  list_neurons: ActorMethod<[ListNeurons], ListNeuronsResponse>;
  list_node_provider_rewards: ActorMethod<
    [ListNodeProviderRewardsRequest],
    ListNodeProviderRewardsResponse
  >;
  list_node_providers: ActorMethod<[], ListNodeProvidersResponse>;
  list_proposals: ActorMethod<[ListProposalInfo], ListProposalInfoResponse>;
  manage_neuron: ActorMethod<[ManageNeuronRequest], ManageNeuronResponse>;
  settle_community_fund_participation: ActorMethod<
    [SettleCommunityFundParticipation],
    Result
  >;
  settle_neurons_fund_participation: ActorMethod<
    [SettleNeuronsFundParticipationRequest],
    SettleNeuronsFundParticipationResponse
  >;
  simulate_manage_neuron: ActorMethod<
    [ManageNeuronRequest],
    ManageNeuronResponse
  >;
  transfer_gtc_neuron: ActorMethod<[NeuronId, NeuronId], Result>;
  update_node_provider: ActorMethod<[UpdateNodeProvider], Result>;
}
export declare const idlService: IDL.ServiceClass;
export declare const idlInitArgs: IDL.Type[];
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];
