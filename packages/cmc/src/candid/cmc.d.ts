/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.2.0.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import type { ActorMethod } from "@icp-sdk/core/agent";
import type { IDL } from "@icp-sdk/core/candid";
import type { Principal } from "@icp-sdk/core/principal";

export type AccountIdentifier = string;
export type BlockIndex = bigint;
export interface CanisterSettings {
  freezing_threshold: [] | [bigint];
  wasm_memory_threshold: [] | [bigint];
  environment_variables: [] | [Array<environment_variable>];
  controllers: [] | [Array<Principal>];
  reserved_cycles_limit: [] | [bigint];
  log_visibility: [] | [log_visibility];
  log_memory_limit: [] | [bigint];
  wasm_memory_limit: [] | [bigint];
  memory_allocation: [] | [bigint];
  compute_allocation: [] | [bigint];
}
export type ChangeSubnetTypeAssignmentArgs =
  | { Add: SubnetListWithType }
  | { Remove: SubnetListWithType };
/**
 * The argument of the [create_canister] method.
 */
export interface CreateCanisterArg {
  /**
   * Optional instructions to select on which subnet the new canister will be created on.
   */
  subnet_selection: [] | [SubnetSelection];
  /**
   * Optional canister settings that, if set, are applied to the newly created canister.
   * If not specified, the caller is the controller of the canister and the other settings are set to default values.
   */
  settings: [] | [CanisterSettings];
  /**
   * An optional subnet type that, if set, determines what type of subnet
   * the new canister will be created on.
   * Deprecated. Use subnet_selection instead.
   */
  subnet_type: [] | [string];
}
/**
 * Canister creation failed and the cycles attached to the call were returned to the calling canister.
 * A small fee may be charged.
 */
export type CreateCanisterError = {
  Refunded: {
    /**
     * The reason why creating a canister failed.
     */
    create_error: string;
    /**
     * The amount of cycles returned to the calling canister
     */
    refund_amount: bigint;
  };
};
export type CreateCanisterResult =
  | {
      /**
       * The principal of the newly created canister.
       */
      Ok: Principal;
    }
  | { Err: CreateCanisterError };
export type Cycles = bigint;
export interface CyclesCanisterInitPayload {
  exchange_rate_canister: [] | [ExchangeRateCanister];
  cycles_ledger_canister_id: [] | [Principal];
  last_purged_notification: [] | [bigint];
  governance_canister_id: [] | [Principal];
  minting_account_id: [] | [AccountIdentifier];
  ledger_canister_id: [] | [Principal];
}
export type ExchangeRateCanister =
  | {
      /**
       * / Enables the exchange rate canister with the given canister ID.
       */
      Set: Principal;
    }
  | {
      /**
       * / Disable the exchange rate canister.
       */
      Unset: null;
    };
export interface IcpXdrConversionRate {
  /**
   * The number of 10,000ths of IMF SDR (currency code XDR) that corresponds
   * to 1 ICP. This value reflects the current market price of one ICP token.
   */
  xdr_permyriad_per_icp: bigint;
  /**
   * The time for which the market data was queried, expressed in UNIX epoch
   * time in seconds.
   */
  timestamp_seconds: bigint;
}
export interface IcpXdrConversionRateResponse {
  /**
   * System certificate as specified in
   * https://internetcomputer.org/docs/interface-spec/index.html#certification-encoding
   */
  certificate: Uint8Array;
  /**
   * The latest ICP/XDR conversion rate.
   */
  data: IcpXdrConversionRate;
  /**
   * CBOR-serialized hash tree as specified in
   * https://internetcomputer.org/docs/interface-spec/index.html#certification-encoding
   * The hash tree is used for certification and hash the following structure:
   * ```
   * *
   * |
   * +-- ICP_XDR_CONVERSION_RATE -- [ Candid encoded IcpXdrConversionRate ]
   * |
   * `-- AVERAGE_ICP_XDR_CONVERSION_RATE -- [ Candid encoded IcpXdrConversionRate ]
   * ```
   */
  hash_tree: Uint8Array;
}
export type Memo = [] | [Uint8Array];
/**
 * The argument of the [notify_create_canister] method.
 */
export interface NotifyCreateCanisterArg {
  /**
   * The controller of canister to create.
   */
  controller: Principal;
  /**
   * Index of the block on the ICP ledger that contains the payment.
   */
  block_index: BlockIndex;
  /**
   * Optional instructions to select on which subnet the new canister will be created on.
   * vec may contain no more than one element.
   */
  subnet_selection: [] | [SubnetSelection];
  /**
   * Optional canister settings that, if set, are applied to the newly created canister.
   * If not specified, the caller is the controller of the canister and the other settings are set to default values.
   */
  settings: [] | [CanisterSettings];
  /**
   * An optional subnet type that, if set, determines what type of subnet
   * the new canister will be created on.
   * Deprecated. Use subnet_selection instead.
   */
  subnet_type: [] | [string];
}
export type NotifyCreateCanisterResult =
  | {
      /**
       * The principal of the newly created canister.
       */
      Ok: Principal;
    }
  | { Err: NotifyError };
export type NotifyError =
  | {
      /**
       * The payment processing failed and the payment was returned the caller.
       * This is a non-retriable error.
       */
      Refunded: {
        /**
         * The index of the block containing the refund.
         */
        block_index: [] | [BlockIndex];
        /**
         * The reason for the refund.
         */
        reason: string;
      };
    }
  | {
      /**
       * The transaction does not satisfy the cycle minting canister payment protocol.
       * The text contains the description of the problem.
       * This is a non-retriable error.
       */
      InvalidTransaction: string;
    }
  | {
      /**
       * Other error.
       */
      Other: { error_message: string; error_code: bigint };
    }
  | {
      /**
       * The same payment is already being processed by a concurrent request.
       * This is a retriable error.
       */
      Processing: null;
    }
  | {
      /**
       * The payment was too old to be processed.
       * The value of the variant is the oldest block index that can still be processed.
       * This a non-retriable error.
       */
      TransactionTooOld: BlockIndex;
    };
export interface NotifyMintCyclesArg {
  block_index: BlockIndex;
  deposit_memo: Memo;
  to_subaccount: Subaccount;
}
export type NotifyMintCyclesResult =
  | { Ok: NotifyMintCyclesSuccess }
  | { Err: NotifyError };
export interface NotifyMintCyclesSuccess {
  /**
   * New balance of the cycles ledger account
   */
  balance: bigint;
  /**
   * Cycles ledger block index of deposit
   */
  block_index: bigint;
  /**
   * Amount of cycles that were minted and deposited to the cycles ledger
   */
  minted: bigint;
}
/**
 * The argument of the [notify_top_up] method.
 */
export interface NotifyTopUpArg {
  /**
   * Index of the block on the ICP ledger that contains the payment.
   */
  block_index: BlockIndex;
  /**
   * The canister to top up.
   */
  canister_id: Principal;
}
export type NotifyTopUpResult =
  | {
      /**
       * The amount of cycles sent to the specified canister.
       */
      Ok: Cycles;
    }
  | { Err: NotifyError };
export interface PrincipalsAuthorizedToCreateCanistersToSubnetsResponse {
  data: Array<[Principal, Array<Principal>]>;
}
export interface SetAuthorizedSubnetworkListArgs {
  who: [] | [Principal];
  subnets: Array<Principal>;
}
export type Subaccount = [] | [Uint8Array];
export interface SubnetFilter {
  subnet_type: [] | [string];
}
export interface SubnetListWithType {
  subnets: Array<Principal>;
  subnet_type: string;
}
export type SubnetSelection =
  | {
      /**
       * / Choose a random subnet that fulfills the specified properties
       */
      Filter: SubnetFilter;
    }
  | {
      /**
       * / Choose a specific subnet
       */
      Subnet: { subnet: Principal };
    };
export interface SubnetTypesToSubnetsResponse {
  data: Array<[string, Array<Principal>]>;
}
export type UpdateSubnetTypeArgs = { Add: string } | { Remove: string };
export interface environment_variable {
  value: string;
  name: string;
}
export type log_visibility =
  | { controllers: null }
  | { public: null }
  | { allowed_viewers: Array<Principal> };
export interface _SERVICE {
  change_subnet_type_assignment: ActorMethod<
    [ChangeSubnetTypeAssignmentArgs],
    undefined
  >;
  /**
   * Creates a canister using the cycles attached to the function call.
   */
  create_canister: ActorMethod<[CreateCanisterArg], CreateCanisterResult>;
  get_build_metadata: ActorMethod<[], string>;
  get_default_subnets: ActorMethod<[], Array<Principal>>;
  /**
   * Returns the ICP/XDR conversion rate.
   */
  get_icp_xdr_conversion_rate: ActorMethod<[], IcpXdrConversionRateResponse>;
  /**
   * Returns the mapping from principals to subnets in which they are authorized
   * to create canisters.
   */
  get_principals_authorized_to_create_canisters_to_subnets: ActorMethod<
    [],
    PrincipalsAuthorizedToCreateCanistersToSubnetsResponse
  >;
  /**
   * Returns the current mapping of subnet types to subnets.
   */
  get_subnet_types_to_subnets: ActorMethod<[], SubnetTypesToSubnetsResponse>;
  /**
   * Prompts the cycles minting canister to process a payment for canister creation.
   */
  notify_create_canister: ActorMethod<
    [NotifyCreateCanisterArg],
    NotifyCreateCanisterResult
  >;
  /**
   * Mints cycles and deposits them to the cycles ledger
   */
  notify_mint_cycles: ActorMethod<
    [NotifyMintCyclesArg],
    NotifyMintCyclesResult
  >;
  /**
   * Prompts the cycles minting canister to process a payment by converting ICP
   * into cycles and sending the cycles the specified canister.
   */
  notify_top_up: ActorMethod<[NotifyTopUpArg], NotifyTopUpResult>;
  /**
   * Below are methods that can only be called by other NNS canisters.
   */
  set_authorized_subnetwork_list: ActorMethod<
    [SetAuthorizedSubnetworkListArgs],
    undefined
  >;
  update_subnet_type: ActorMethod<[UpdateSubnetTypeArgs], undefined>;
}
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];
